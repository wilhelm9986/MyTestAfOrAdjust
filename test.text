*******************************************************************************
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />

    <receiver
            android:name="com.adjust.sdk.AdjustReferrerReceiver"
            android:exported="true"
            android:permission="android.permission.INSTALL_PACKAGES"
            tools:ignore="WrongManifestParent">
            <intent-filter>
                <action android:name="com.android.vending.INSTALL_REFERRER" />
            </intent-filter>
        </receiver>
    
*******************************************************************************
    implementation 'com.appsflyer:af-android-sdk:6.15.2'
    implementation 'com.adjust.sdk:adjust-android:5.1.0'
    implementation 'com.android.installreferrer:installreferrer:2.2'
    implementation 'com.adjust.sdk:adjust-android-webbridge:5.1.0'
    implementation 'com.google.android.gms:play-services-ads-identifier:18.0.1'
    implementation 'com.squareup.okhttp3:okhttp:4.12.0'

*******************************************************************************

package com.data.protect;

import android.os.Build;

import androidx.annotation.Keep;
import androidx.annotation.RequiresApi;

import java.nio.charset.StandardCharsets;
import java.util.Base64;
import java.util.concurrent.ConcurrentHashMap;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

@RequiresApi(Build.VERSION_CODES.O)
@Keep
public class SafeText {
    @Keep
    private static final String process = "AES/ECB/PKCS5Padding";

    @Keep
    private static final String KEY = "52093fc1f194a9bfeab67513acaad9a7a96e1d71055c8cb880c974ad17485315";

    @Keep
    private static final ConcurrentHashMap<String, String> decryptCache = new ConcurrentHashMap<>();

    @Keep
    private static final SecretKeySpec keySpec;

    static {
        byte[] keyBytes = new byte[32];
        for (int i = 0; i < KEY.length(); i += 2) {
            keyBytes[i / 2] = (byte) Integer.parseInt(KEY.substring(i, i + 2), 16);
        }
        keySpec = new SecretKeySpec(keyBytes, process);
    }

    @RequiresApi(Build.VERSION_CODES.O)
    @Keep
    public static String recover(String base64Str, String key) {

        String cacheKey = base64Str + ":" + key;

        return decryptCache.computeIfAbsent(cacheKey, k -> {
            try {
                byte[] encryptedBytes = Base64.getDecoder().decode(base64Str);

                Cipher cipher = Cipher.getInstance(process);
                SecretKeySpec currentKeySpec;
                if (key.equals(KEY)) {
                    currentKeySpec = keySpec;
                } else {
                    byte[] customKeyBytes = new byte[32];
                    for (int i = 0; i < key.length(); i += 2) {
                        customKeyBytes[i / 2] = (byte) Integer.parseInt(key.substring(i, i + 2), 16);
                    }
                    currentKeySpec = new SecretKeySpec(customKeyBytes, process);
                }
                cipher.init(Cipher.DECRYPT_MODE, currentKeySpec);
                return new String(cipher.doFinal(encryptedBytes), StandardCharsets.UTF_8);
            } catch (Exception e) {
                try {
                    byte[] bytes = Base64.getDecoder().decode(base64Str);
                    byte[] result = new byte[bytes.length];
                    int keyHash = key.hashCode();
                    for (int i = 0; i < bytes.length; i++) {
                        result[i] = (byte) (bytes[i] ^ keyHash);
                    }
                    return new String(result, StandardCharsets.UTF_8);
                } catch (Exception e2) {
                    return base64Str;
                }
            }
        });
    }

    @RequiresApi(Build.VERSION_CODES.O)
    @Keep
    public static String recover(String base64Str) {
        return recover(base64Str, KEY);
    }

}
