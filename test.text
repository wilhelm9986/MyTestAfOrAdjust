*******************************************************************************
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />

    <receiver
            android:name="com.adjust.sdk.AdjustReferrerReceiver"
            android:exported="true"
            android:permission="android.permission.INSTALL_PACKAGES"
            tools:ignore="WrongManifestParent">
            <intent-filter>
                <action android:name="com.android.vending.INSTALL_REFERRER" />
            </intent-filter>
        </receiver>
    
*******************************************************************************
    implementation 'com.appsflyer:af-android-sdk:6.15.2'
    implementation 'com.adjust.sdk:adjust-android:5.1.0'
    implementation 'com.android.installreferrer:installreferrer:2.2'
    implementation 'com.adjust.sdk:adjust-android-webbridge:5.1.0'
    implementation 'com.google.android.gms:play-services-ads-identifier:18.0.1'
    implementation 'com.squareup.okhttp3:okhttp:4.12.0'

*******************************************************************************
package com.data.protect;

import com.android.build.api.instrumentation.InstrumentationParameters;
import com.android.build.api.instrumentation.InstrumentationScope;
import com.android.build.api.variant.AndroidComponentsExtension;
import com.android.build.gradle.AppExtension;

import org.gradle.api.Plugin;
import org.gradle.api.Project;
import org.gradle.api.logging.Logger;
import org.gradle.api.logging.Logging;
import org.gradle.api.provider.ListProperty;
import org.gradle.api.provider.Property;
import org.gradle.api.tasks.Input;

import java.util.Arrays;


public abstract class AiStringPlugin implements Plugin<Project> {

    public static String AiStringJava = "src/main/java/com/data/protect/SafeText.java";
    public static String AiString = "com/data/protect/SafeText";

    private final Logger logger = Logging.getLogger(AiStringPlugin.class);

    public interface StringEncryptParams extends InstrumentationParameters {
        @Input
        Property<String> getKey();

        @Input
        ListProperty<String> getTargetPackages();
    }

    @Override
    public void apply(Project project) {
        project.getPlugins().withId("com.android.application", androidPlugin -> {
            boolean isReleaseBuild = project.getGradle().getStartParameter().getTaskNames().stream()
                    .anyMatch(task -> task.toLowerCase().contains("release"));

            try {
                // 生成密钥
                String key = KeyGenerator.generateKey();

                // 创建 RuntimeKeyUpdater 实例，更新密钥
                Project runtimeProject = project.getRootProject().findProject(":runtime");
                if (runtimeProject != null) {
//                    logger.lifecycle("找到runtime模块，开始更新密钥");
                    RuntimeKeyUpdater runtimeKeyUpdater = new RuntimeKeyUpdater();
                    runtimeKeyUpdater.updateKey(runtimeProject, key);  // 调用更新密钥的方法
                } else {
                    logger.error("未找到runtime模块，请检查项目配置");
                    return;
                }

                // 使用 ASM 注册字符串加密操作
                AndroidComponentsExtension<?, ?, ?> androidComponents = project.getExtensions().getByType(AndroidComponentsExtension.class);
//                logger.lifecycle("开始注册字符串加密转换");

                androidComponents.onVariants(androidComponents.selector().all(), (variant) -> {
                    // 从 build.gradle 中获取包名
                    Object namespaceObj = project.getProperties().get("android.namespace");
                    String namespace = namespaceObj != null ? namespaceObj.toString() : null;
                    
                    if (namespace == null) {
                        Object applicationIdObj = project.getProperties().get("android.defaultConfig.applicationId");
                        namespace = applicationIdObj != null ? applicationIdObj.toString() : null;
                    }
                    
                    if (namespace == null) {
                        // 尝试从 android 扩展获取
                        try {
                            AppExtension android = project.getExtensions().getByType(AppExtension.class);
                            namespace = android.getDefaultConfig().getApplicationId();
                        } catch (Exception e) {
                            logger.warn("无法从 android 扩展获取包名");
                        }
                    }
                    
                    if (namespace == null) {
                        throw new IllegalStateException("无法获取应用包名，请在 build.gradle 中设置 namespace 或 applicationId");
                    }
                    
                    final String packageName = namespace;
//                    logger.lifecycle("应用包名: " + packageName);
                    
//                    logger.lifecycle("处理变体: " + variant.getName());
                    if (variant.getInstrumentation() != null) {
//                        logger.lifecycle("开始设置字符串加密转换器");
                        variant.getInstrumentation().transformClassesWith(
                                StringEncryptorFactory.class,
                                InstrumentationScope.ALL,
                                params -> {
                                    params.getKey().set(key);
                                    // 使用应用包名
                                    params.getTargetPackages().set(Arrays.asList(packageName.replace(".", "/")));
//                                    logger.lifecycle("字符串加密转换器设置完成，目标包名: " + packageName);
                                    return null;
                                }
                        );
                    } else {
                        logger.lifecycle("Instrumentation 不存在，跳过变体: " + variant.getName());
                    }
                });
            } catch (Exception e) {
                logger.error("插件执行过程中发生错误: " + e.getMessage());
                e.printStackTrace();
                throw e;
            }
        });
    }
}
*******************************************************************************
package com.data.protect;

public class KeyGenerator {
    public static String generateKey() {
        byte[] key = new byte[32]; // 256位密钥
        new java.security.SecureRandom().nextBytes(key);
        StringBuilder hexString = new StringBuilder();
        for (byte b : key) {
            hexString.append(String.format("%02x", b));
        }
        return hexString.toString();
    }
}
*******************************************************************************
package com.data.protect;

import org.gradle.api.Project;

import java.io.File;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.StandardOpenOption;

public class RuntimeKeyUpdater {

    public void updateKey(Project runtimeProject, String key) {
        File runtimeDir = runtimeProject.getProjectDir();
        File aiStringFile = new File(runtimeDir, AiStringPlugin.AiStringJava);

        if (aiStringFile.exists()) {
            try {
                String content = Files.readString(aiStringFile.toPath(), StandardCharsets.UTF_8);
                String pattern = "private\\s+static\\s+final\\s+String\\s+KEY\\s*=\\s*\"([^\"]*)\"";
                content = content.replaceAll(pattern, "private static final String KEY = \"" + key + "\"");

                // 写回文件
                Files.writeString(aiStringFile.toPath(), content, StandardCharsets.UTF_8, StandardOpenOption.TRUNCATE_EXISTING);
//                System.out.println("成功替换密钥: " + key);
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}

*******************************************************************************
package com.data.protect;

import org.objectweb.asm.ClassVisitor;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;

import java.util.List;

public class StringClassVisitor extends ClassVisitor {
    private final StringEncryptor encryptor;
    private final String key;
    private final List<String> targetPackages;

    public StringClassVisitor(ClassVisitor classVisitor, StringEncryptor encryptor, String key, List<String> targetPackages) {
        super(Opcodes.ASM9, classVisitor);
        this.encryptor = encryptor;
        this.key = key;
        this.targetPackages = targetPackages;
    }

    private String className;

    @Override
    public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
        this.className = name;
        super.visit(version, access, name, signature, superName, interfaces);
    }

    @Override
    public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {
        MethodVisitor methodVisitor = super.visitMethod(access, name, descriptor, signature, exceptions);
        if (methodVisitor != null) {
            return new StringMethodVisitor(methodVisitor, encryptor, key, targetPackages, access, name, descriptor, className);
        }
        return null;
    }
}
*******************************************************************************
package com.data.protect;

import org.gradle.api.logging.Logger;
import org.gradle.api.logging.Logging;

import java.io.Serializable;
import java.nio.charset.StandardCharsets;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;

public class StringEncryptor implements Serializable {
    private transient final String algorithm = "AES/ECB/PKCS5Padding";
    private static final Logger logger = Logging.getLogger(StringEncryptor.class);

    public byte[] encrypt(String input, String key) {
        try {
            // 将十六进制密钥转换为字节数组
            byte[] keyBytes = new byte[32];
            for (int i = 0; i < key.length(); i += 2) {
                keyBytes[i / 2] = (byte) Integer.parseInt(key.substring(i, i + 2), 16);
            }
            SecretKeySpec keySpec = new SecretKeySpec(keyBytes, algorithm);

            Cipher cipher = Cipher.getInstance(algorithm);
            cipher.init(Cipher.ENCRYPT_MODE, keySpec);

            // 使用 UTF-8 编码
            return cipher.doFinal(input.getBytes(StandardCharsets.UTF_8));
        } catch (Exception e) {
            // 如果AES加密失败，回退到简单的XOR加密
            byte[] inputBytes = input.getBytes(StandardCharsets.UTF_8);
            byte[] result = new byte[inputBytes.length];
            int keyHash = key.hashCode();
            for (int i = 0; i < inputBytes.length; i++) {
                result[i] = (byte) (inputBytes[i] ^ keyHash);
            }
            return result;
        }
    }
}
*******************************************************************************
package com.data.protect;

import com.android.build.api.instrumentation.AsmClassVisitorFactory;
import com.android.build.api.instrumentation.ClassContext;
import com.android.build.api.instrumentation.ClassData;

import org.objectweb.asm.ClassVisitor;

import java.util.Collections;
import java.util.List;

public abstract class StringEncryptorFactory implements AsmClassVisitorFactory<AiStringPlugin.StringEncryptParams> {

    @Override
    public ClassVisitor createClassVisitor(ClassContext classContext, ClassVisitor nextClassVisitor) {
        AiStringPlugin.StringEncryptParams params = getParameters().getOrElse(null);
        if (params != null) {
            String key = params.getKey().getOrElse(null);
            List<String> targetPackages = params.getTargetPackages().getOrElse(Collections.emptyList());
            StringEncryptor encryptor = new StringEncryptor();
            return new StringClassVisitor(nextClassVisitor, encryptor, key, targetPackages);
        } else {
            throw new IllegalStateException("Instrumentation parameters not found!");
        }
    }

    @Override
    public boolean isInstrumentable(ClassData classData) {
        return true;
    }
}

*******************************************************************************
package com.data.protect;

import org.gradle.api.logging.Logger;
import org.gradle.api.logging.Logging;
import org.objectweb.asm.MethodVisitor;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.commons.AdviceAdapter;

import java.util.Base64;
import java.util.List;

public class StringMethodVisitor extends AdviceAdapter {
    private final StringEncryptor encryptor;
    private final String key;
    private final String className;
    private final List<String> targetPackages;
    private static final Logger logger = Logging.getLogger(StringMethodVisitor.class);

    public StringMethodVisitor(
            MethodVisitor methodVisitor,
            StringEncryptor encryptor,
            String key,
            List<String> targetPackages,
            int access,
            String name,
            String descriptor,
            String className
    ) {
        super(Opcodes.ASM9, methodVisitor, access, name, descriptor);
        this.encryptor = encryptor;
        this.key = key;
        this.targetPackages = targetPackages;
        this.className = className;
    }

    private boolean shouldEncrypt(String value) {
        if (value == null || value.isEmpty()) {
            return false;
        }
        
        // 只加密指定包名下的代码
        if (this.className != null && targetPackages != null) {
            return targetPackages.stream().anyMatch(pkg -> this.className.contains(pkg));
        }
        
        return false;
    }

    private String encryptString(String value) {
        try {
            byte[] encrypted = encryptor.encrypt(value, key);
            return Base64.getEncoder().encodeToString(encrypted);
        } catch (Exception e) {
            logger.warn("[StringMethodVisitor] 加密失败: {}", e.getMessage());
            return value;
        }
    }


    @Override
    public void visitLdcInsn(Object value) {
        if (value instanceof String && !((String) value).isEmpty() && shouldEncrypt((String) value)) {
            try {
                String processedValue = ((String) value).replace("\n", "\\n");
                String base64Str = encryptString(processedValue);
//                logger.warn("字符串加密: 原始值='{}', 加密后='{}'" , processedValue, base64Str);
                super.visitLdcInsn(base64Str);
                super.visitLdcInsn(key);
                super.visitMethodInsn(
                        Opcodes.INVOKESTATIC,
                        AiStringPlugin.AiString,
                        "recover",
                        "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;",
                        false
                );

            } catch (Exception e) {
                logger.warn("[StringMethodVisitor] 处理字符串时发生错误: {}", e.getMessage());
                super.visitLdcInsn(value);
            }
        } else {
            super.visitLdcInsn(value);
        }
    }
}
*******************************************************************************
plugins {
    id 'java-gradle-plugin'
}

repositories {
    gradlePluginPortal()
    mavenCentral()
    google()
}

dependencies {
    implementation "com.android.tools.build:gradle:8.2.0"
    implementation "org.ow2.asm:asm:9.6"
    implementation "org.ow2.asm:asm-commons:9.6"

}

java {
    sourceCompatibility = JavaVersion.VERSION_11
    targetCompatibility = JavaVersion.VERSION_11
}

gradlePlugin {
    plugins {
        aiStringPlugin {
            id = 'com.data.protect'
            implementationClass = 'com.data.protect.AiStringPlugin'
        }
    }
}
*******************************************************************************
plugins {
    id 'com.android.library'
}

android {
    namespace 'com.data.protect'
    //namespace 'com.doctor.aistring'
    compileSdk 34

    defaultConfig {
        minSdk 24
        targetSdk 34
    }

    buildTypes {
        release {
            minifyEnabled true
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
            consumerProguardFiles 'proguard-rules.pro'
            debuggable false
        }
        debug {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
            consumerProguardFiles 'proguard-rules.pro'
            debuggable false
        }
    }

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_11
        targetCompatibility = JavaVersion.VERSION_11
    }


}

dependencies {
    implementation 'androidx.annotation:annotation:1.7.1'

}

-keep class com.data.protect.SafeText { *; }
-keep class com.data.protect.SafeText* { *; }


